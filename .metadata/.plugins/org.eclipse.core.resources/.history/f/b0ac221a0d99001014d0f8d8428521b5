package com.aurionpro.service;



import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.aurionpro.dto.AddressRequest;
import com.aurionpro.dto.LoginDto;
import com.aurionpro.dto.RegistrationDto;
import com.aurionpro.dto.UserResponse;
import com.aurionpro.entity.Address;
import com.aurionpro.entity.Customer;
import com.aurionpro.entity.Role;
import com.aurionpro.entity.User;
import com.aurionpro.exception.UserApiException;
import com.aurionpro.repository.RoleRepo;
import com.aurionpro.repository.UserRepo;
import com.aurionpro.security.JwtTokenProvider;

import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;

@Service
@AllArgsConstructor
@RequiredArgsConstructor
public class AuthServiceImpl implements AuthService {

	@Autowired
	private AuthenticationManager authenticationManager;
	@Autowired
	private UserRepo userRepo;
	@Autowired
	private RoleRepo roleRepo;
	@Autowired
	private PasswordEncoder passwordEncoder;
	@Autowired
	private JwtTokenProvider tokenProvider;
	
	
	
	
	
	

	@Override
	public UserResponse register(RegistrationDto registerDto) {
	    if (userRepo.existsByUsername(registerDto.getUsername()))
	        throw new UserApiException(HttpStatus.BAD_REQUEST, "User already exists");

	    User user = new User();
	    user.setUsername(registerDto.getUsername());
	    user.setPassword(passwordEncoder.encode(registerDto.getPassword()));

	    Role userRole = roleRepo.findByRolename(registerDto.getRole())
	            .orElseThrow(() -> new UserApiException(HttpStatus.BAD_REQUEST, "Role does not exists"));
	    user.setRole(userRole);
	    userRole.getUsers().add(user);

	    // ✅ Save user first (so we have a userId)
	    user = userRepo.save(user);

	    // ✅ If role is CUSTOMER, create a Customer linked to this user
	    if ("ROLE_CUSTOMER".equalsIgnoreCase(registerDto.getRole()) && registerDto.getCustomer() != null) {
	        Customer customer = new Customer();
	        customer.setFirstName(registerDto.getCustomer().getFirstName());
	        customer.setLastName(registerDto.getCustomer().getLastName());
	        customer.setEmailid(registerDto.getCustomer().getEmailid());
	        customer.setContactno(registerDto.getCustomer().getContactno());
	        customer.setDob(registerDto.getCustomer().getDob());
	        AddressRequest addressReq = registerDto.getCustomer().getAddress();
	        Address address = new Address();
	        address.setCity(addressReq.getCity());
	        address.setState(addressReq.getState());
	        address.setPincode(addressReq.getPincode());

	        customer.setAddress(address);

	        customer.setUser(user); // link user -> customer

	        user.setCustomer(customer); // link customer -> user

	        // save customer
	        // Because cascade ALL is set on user -> customer, saving user again saves customer
	        user = userRepo.save(user);
	    }

	    UserResponse dto = new UserResponse();
	    dto.setUserId(user.getUserId());
	    dto.setUsername(user.getUsername());
	    dto.setRole(user.getRole().getRolename()); // return role info

	    return dto;
	}


	@Override
	public String login(LoginDto loginDto) {
		try {
			Authentication authentication = authenticationManager.authenticate(
					new UsernamePasswordAuthenticationToken(loginDto.getUsername(), loginDto.getPassword()));
			SecurityContextHolder.getContext().setAuthentication(authentication);
			String token = tokenProvider.generateToken(authentication);

			return token;
		} catch (BadCredentialsException e) {
			throw new UserApiException(HttpStatus.NOT_FOUND, "Username or Password is incorrect");
		}
	}

}
